<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1.0"></meta><title>Диспетчерская - План завода</title><style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    
    body {
        font-family: Arial, sans-serif;
        background-color: #f5f5f5;
        overflow: auto;
    }
    
    .container {
        width: 100%;
        height: 100vh;
        position: relative;
        overflow: auto;
        background-color: #e0e0e0;
    }
    
    .map-container {
        width: 100%;
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        padding: 20px;
    }
    
    .map-stage {
        position: relative;
        display: inline-block;
    }
    
    .map-image {
        max-width: 100%;
        height: auto;
        display: block;
    }
    
    #interactive-areas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
    }
    
    .interactive-area {
        position: absolute;
        cursor: pointer;
        border: 2px solid transparent;
        transition: border-color 0.3s ease;
        z-index: 10;
    }
    
    .interactive-area:hover {
        border-color: #4CAF50;
        background-color: rgba(76, 175, 80, 0.1);
    }
    
    .popup {
        position: fixed;
        background-color: white;
        border: 2px solid #4CAF50;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        padding: 15px;
        min-width: 300px;
        max-width: 500px;
        max-height: 80vh;
        overflow-y: auto;
        z-index: 1000;
        display: none;
        font-size: 14px;
    }
    
    .popup.visible {
        display: block;
    }
    
    .popup-header {
        font-weight: bold;
        font-size: 16px;
        color: #4CAF50;
        margin-bottom: 10px;
        padding-bottom: 8px;
        border-bottom: 2px solid #4CAF50;
    }
    
    .popup-content {
        margin-top: 10px;
    }
    
    .popup-item {
        padding: 8px 0;
        border-bottom: 1px solid #eee;
    }
    
    .popup-item:last-child {
        border-bottom: none;
    }
    
    .popup-item-title {
        font-weight: bold;
        color: #333;
        margin-bottom: 4px;
    }
    
    .popup-item-detail {
        color: #666;
        font-size: 12px;
        margin-left: 10px;
    }
    
    .popup-no-data {
        color: #999;
        font-style: italic;
        text-align: center;
        padding: 10px;
    }
    
    .popup-close {
        position: absolute;
        top: 5px;
        right: 10px;
        cursor: pointer;
        font-size: 20px;
        color: #999;
        line-height: 1;
    }
    
    .popup-close:hover {
        color: #333;
    }
</style></head><body>
<div class="container">
    <div class="map-container">
        <div class="map-stage">
            <img id="map-image" class="map-image" src="" alt="План завода"></img><div id="interactive-areas"></div>
        </div>
    </div>
</div>

<div id="popup" class="popup">
    <span class="popup-close" onclick="closePopup()">×</span>
    <div class="popup-header" id="popup-header"></div>
    <div class="popup-content" id="popup-content"></div>
</div>

<script>
    // Определение данных
    const externalData = "{причал: Плавдок № 20, судно: DE MI, вид_подхода: Фактический, дата_швартовки: 14.11.2025 8:00:00, дата_выбытия: 19.11.2025 14:11:53},{причал: Плавдок № 20, судно: GLORY STAR, вид_подхода: Фактический, дата_швартовки: 14.11.2025 9:00:00, дата_выбытия: 19.11.2025 14:11:53},{причал: Причал №26, судно: GLORY STAR, вид_подхода: Фактический, дата_швартовки: 18.11.2025 8:00:00, дата_выбытия: 18.11.2025 7:59:59}";
    
    // Пути к данным и изображению карты
    const interactiveAreasData = "{name: СЛИП, x: 213, y: 266, width: 48, height: 12, matchField: причал, matchValue: СЛИП},{name: причал №27, x: 381,1, y: 217,9, width: 48, height: 12, matchField: причал, matchValue: причал №27},{name: причал №26, x: 288,7, y: 194,9, width: 48, height: 12, matchField: причал, matchValue: причал №26},{name: причал №28, x: 487,9, y: 289,5, width: 48, height: 12, matchField: причал, matchValue: причал №28},{name: пирс №1, x: 366,5, y: 119,8, width: 30,5, height: 30,5, matchField: пирс, matchValue: пирс №1},{name: П\Д 20к, x: 478,1, y: 123,6, width: 30,5, height: 30,5, matchField: док, matchValue: П\Д 20к},{name: П\Д 2, x: 543,1, y: 146,4, width: 30,5, height: 30,5, matchField: док, matchValue: П\Д 2},{name: пирс №2, x: 862,1, y: 169,2, width: 36,5, height: 41, matchField: пирс, matchValue: пирс №2},{name: причал №30, x: 792,5, y: 297,8, width: 48, height: 12, matchField: причал, matchValue: причал №30},{name: причал №31, x: 925,9, y: 274,3, width: 48, height: 12, matchField: причал, matchValue: причал №31},{name: причал ВМФ, x: 113, y: 278,9, width: 30,5, height: 30,5, matchField: причал, matchValue: причал ВМФ}";
    const mapImagePath = "C:/Users/O.Iunina/Desktop/Projects/_Dispetcherskaya/yard_map.jpg";
</script><script>
    let parsedData = null;
    let interactiveAreas = [];
    let mapImage = null;
    let interactiveAreasContainer = null;
    let mapReady = false;
    let areasReady = false;

    const interactiveAreaSchema = {
        required: ['name', 'x', 'y', 'width', 'height', 'matchField'],
        propertyTypes: {
            name: 'string',
            x: 'number',
            y: 'number',
            width: 'number',
            height: 'number',
            matchField: 'string',
            matchValue: 'string'
        }
    };
    
    // Функция для нормализации путей Windows (конвертация обратных слешей в прямые)
    function normalizePath(path) {
        if (!path || typeof path !== 'string') {
            return path;
        }
        // Заменяем обратные слеши на прямые
        return path.replace(/\\/g, '/');
    }
    
    // Функция для конвертации абсолютного пути Windows в file:// URL
    function convertToFileUrl(path) {
        if (!path || typeof path !== 'string') {
            return path;
        }
        // Если путь уже является URL, возвращаем как есть
        if (path.startsWith('http://') || path.startsWith('https://') || path.startsWith('file://')) {
            return path;
        }
        // Если это абсолютный путь Windows (начинается с буквы диска)
        if (/^[A-Za-z]:/.test(path)) {
            const normalized = normalizePath(path);
            return 'file:///' + normalized;
        }
        // Иначе возвращаем нормализованный путь
        return normalizePath(path);
    }
    
    function buildJsonFromObjectStrings(rawString) {
        const cleanedString = rawString.trim().replace(/^\[/, '').replace(/\]$/, '');
        if (!cleanedString) {
            return '[]';
        }

        const objectStrings = cleanedString.split(/}\s*,\s*{/).map(chunk => {
            let normalized = chunk.trim();
            if (!normalized.startsWith('{')) {
                normalized = '{' + normalized;
            }
            if (!normalized.endsWith('}')) {
                normalized = normalized + '}';
            }
            return normalized;
        });

        const jsonReadyObjects = objectStrings.map(chunk => {
            const escapedBackslashes = chunk.replace(/\\/g, '\\\\');
            const quotedKeys = escapedBackslashes.replace(/([{,]\s*)([^,{:]+?)(\s*:\s*)/g, (match, prefix, key, separator) => {
                const safeKey = key.trim().replace(/"/g, '\\"');
                return `${prefix}"${safeKey}"${separator}`;
            });

            const quotedValues = quotedKeys.replace(/:\s*([^,"}{\[\]]+)(?=\s*[},])/g, (match, value) => {
                const trimmedValue = value.trim();

                if (/^-?\d+(?:[.,]\d+)?$/.test(trimmedValue)) {
                    return `: ${trimmedValue.replace(',', '.')}`;
                }

                const safeValue = trimmedValue.replace(/"/g, '\\"');
                return `: "${safeValue}"`;
            });

            return quotedValues;
        });

        return `[${jsonReadyObjects.join(',')}]`;
    }

    function parseObjectsStringManually(dataString) {
        const jsonString = buildJsonFromObjectStrings(dataString);
        const parsed = JSON.parse(jsonString);

        if (!Array.isArray(parsed)) {
            throw new Error('Ожидается массив объектов с данными для карты.');
        }

        return parsed;
    }

    // Функция для парсинга строки данных в массив объектов
    function parseDataString(dataString) {
        if (!dataString || typeof dataString !== 'string') {
            return null;
        }

        const trimmedString = dataString.trim();

        if (!trimmedString) {
            return null;
        }

        try {
            const parsed = JSON.parse(trimmedString);

            if (!Array.isArray(parsed)) {
                throw new Error('Ожидается массив объектов с данными для карты.');
            }

            return parsed;
        } catch (jsonError) {
            try {
                return parseObjectsStringManually(trimmedString);
            } catch (manualError) {
                const message = `Не удалось распарсить строку данных: ${manualError.message}`;
                console.error(message);
                throw new Error(message);
            }
        }
    }

    // Функция для преобразования даты из формата "dd.mm.yyyy hh:mm:ss" в Date
    function parseDateTime(dateTimeString) {
        if (!dateTimeString) return null;
        
        if (dateTimeString.includes('-') || dateTimeString.includes('T')) {
            return new Date(dateTimeString);
        }
        
        const match = dateTimeString.match(/(\d{1,2})\.(\d{1,2})\.(\d{4})\s+(\d{1,2}):(\d{1,2})(?::(\d{1,2}))?/);
        if (match) {
            const [, day, month, year, hour, minute, second] = match;
            const safeSecond = second ?? '00';
            return new Date(year, month - 1, day, hour, minute, safeSecond);
        }
        
        return new Date(dateTimeString);
    }

    // Функция для форматирования даты и времени
    function formatDateTime(dateTimeString) {
        if (!dateTimeString) return '';
        
        const date = parseDateTime(dateTimeString);
        if (!date || isNaN(date.getTime())) return dateTimeString;
        
        return date.toLocaleString('ru-RU', {
            day: '2-digit',
            month: '2-digit',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
    }

    function validateInteractiveAreasData(data) {
        if (!Array.isArray(data)) {
            throw new Error('Интерактивные области должны быть массивом объектов.');
        }

        data.forEach((area, index) => {
            interactiveAreaSchema.required.forEach(field => {
                if (area[field] === undefined) {
                    throw new Error(`Область №${index + 1} не содержит обязательное поле "${field}".`);
                }
            });

            ['x', 'y', 'width', 'height'].forEach(field => {
                if (area[field] !== undefined) {
                    area[field] = Number(String(area[field]).replace(',', '.'));
                }
            });

            Object.entries(interactiveAreaSchema.propertyTypes).forEach(([field, type]) => {
                if (area[field] !== undefined && typeof area[field] !== type) {
                    throw new Error(`Поле "${field}" в области №${index + 1} должно быть типа ${type}.`);
                }
            });
        });
    }

    // Функция для парсинга данных интерактивных областей
    function parseInteractiveAreasString(rawString) {
        if (!rawString || typeof rawString !== 'string') {
            return [];
        }

        try {
            const trimmed = rawString.trim();

            if (!trimmed) {
                return [];
            }

            const parsed = JSON.parse(trimmed);
            validateInteractiveAreasData(parsed);
            return parsed;
        } catch (error) {
            const message = `Не удалось распарсить файл интерактивных областей: ${error.message}`;
            console.error(message);
            throw new Error(message);
        }
    }

    // Функция для нормализации строковых значений
    function normalizeStringValue(value) {
        if (value === undefined || value === null) return '';

        return String(value)
            .trim()
            .replace(/\s+/g, ' ')
            .toLowerCase();
    }

    // Функция для фильтрации данных по объекту
    function filterDataByObject(dataArray, matchField, matchValue) {
        if (!dataArray || !Array.isArray(dataArray)) {
            return [];
        }

        const normalizedMatchValue = normalizeStringValue(matchValue);

        return dataArray.filter(item => {
            const fieldValue = item[matchField];
            if (!fieldValue) return false;

            // Проверяем точное совпадение или вхождение подстроки
            const normalizedFieldValue = normalizeStringValue(fieldValue);

            return (
                normalizedFieldValue === normalizedMatchValue ||
                normalizedFieldValue.includes(normalizedMatchValue) ||
                normalizedMatchValue.includes(normalizedFieldValue)
            );
        });
    }

    function validateAreaBounds(areaConfig, naturalWidth, naturalHeight) {
        const errors = [];

        if (!areaConfig || typeof areaConfig !== 'object') {
            errors.push('Конфигурация области не задана или имеет неверный формат');
            return { isValid: false, errors };
        }

        const numericValues = {};
        ['x', 'y', 'width', 'height'].forEach(field => {
            const value = Number(areaConfig[field]);
            numericValues[field] = value;

            if (!Number.isFinite(value)) {
                errors.push(`Поле ${field} должно быть числом`);
                return;
            }

            if ((field === 'width' || field === 'height') && value <= 0) {
                errors.push(`Поле ${field} должно быть больше 0`);
            }

            if ((field === 'x' || field === 'y') && value < 0) {
                errors.push(`Поле ${field} не может быть отрицательным`);
            }
        });

        if (Number.isFinite(numericValues.x) && Number.isFinite(numericValues.width)) {
            if (numericValues.x + numericValues.width > naturalWidth) {
                errors.push('Область выходит за правую границу карты');
            }
        }

        if (Number.isFinite(numericValues.y) && Number.isFinite(numericValues.height)) {
            if (numericValues.y + numericValues.height > naturalHeight) {
                errors.push('Область выходит за нижнюю границу карты');
            }
        }

        return { isValid: errors.length === 0, errors };
    }

    // Функция для создания интерактивной области
    function createInteractiveArea(areaConfig, scaleX, scaleY) {
        const area = document.createElement('div');
        area.className = 'interactive-area';
        const x = areaConfig.x;
        const y = areaConfig.y;
        const width = areaConfig.width;
        const height = areaConfig.height;

        area.style.left = (x * scaleX) + 'px';
        area.style.top = (y * scaleY) + 'px';
        area.style.width = (width * scaleX) + 'px';
        area.style.height = (height * scaleY) + 'px';
        area.title = areaConfig.name;
        
        area.addEventListener('mouseenter', function(e) {
            showPopup(e, areaConfig);
        });
        
        area.addEventListener('mousemove', function(e) {
            updatePopupPosition(e);
        });
        
        area.addEventListener('mouseleave', function() {
            closePopup();
        });
        
        return area;
    }

    // Функция для отображения всплывающего окна
    function showPopup(event, areaConfig) {
        const popup = document.getElementById('popup');
        const popupHeader = document.getElementById('popup-header');
        const popupContent = document.getElementById('popup-content');
        
        if (!parsedData || !Array.isArray(parsedData)) {
            popupHeader.textContent = areaConfig.name;
            popupContent.innerHTML = '<div class="popup-no-data">Нет данных для отображения</div>';
        } else {
            const normalizedMatchValue = normalizeStringValue(
                areaConfig.matchValue || areaConfig.name
            );

            const filteredData = filterDataByObject(
                parsedData,
                areaConfig.matchField || 'причал',
                normalizedMatchValue
            );
            
            popupHeader.textContent = areaConfig.name;
            
            if (filteredData.length === 0) {
                popupContent.innerHTML = '<div class="popup-no-data">Нет данных для этого объекта</div>';
            } else {
                let contentHTML = '';
                filteredData.forEach((item, index) => {
                    contentHTML += `
                        <div class="popup-item">
                            <div class="popup-item-title">Запись ${index + 1}</div>
                            ${item.судно ? `<div class="popup-item-detail"><strong>Судно:</strong> ${item.судно}</div>` : ''}
                            ${item.причал ? `<div class="popup-item-detail"><strong>Причал:</strong> ${item.причал}</div>` : ''}
                            ${item.вид_подхода ? `<div class="popup-item-detail"><strong>Вид подхода:</strong> ${item.вид_подхода}</div>` : ''}
                            ${item.дата_швартовки ? `<div class="popup-item-detail"><strong>Дата швартовки:</strong> ${formatDateTime(item.дата_швартовки)}</div>` : ''}
                            ${item.дата_выбытия ? `<div class="popup-item-detail"><strong>Дата выбытия:</strong> ${formatDateTime(item.дата_выбытия)}</div>` : ''}
                        </div>
                    `;
                });
                popupContent.innerHTML = contentHTML;
            }
        }
        
        popup.classList.add('visible');
        updatePopupPosition(event);
    }

    // Функция для обновления позиции всплывающего окна
    function updatePopupPosition(event) {
        const popup = document.getElementById('popup');
        const popupRect = popup.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        
        let left = event.clientX + 15;
        let top = event.clientY + 15;
        
        // Корректировка позиции, чтобы попап не выходил за границы экрана
        if (left + popupRect.width > viewportWidth) {
            left = event.clientX - popupRect.width - 15;
        }
        if (top + popupRect.height > viewportHeight) {
            top = event.clientY - popupRect.height - 15;
        }
        
        popup.style.left = left + 'px';
        popup.style.top = top + 'px';
    }

    // Функция для закрытия всплывающего окна
    function closePopup() {
        const popup = document.getElementById('popup');
        popup.classList.remove('visible');
    }

    // Функция для рендеринга интерактивных областей с учетом масштаба
    function renderInteractiveAreas() {
        if (!mapReady || !areasReady || !mapImage || !interactiveAreasContainer) {
            return;
        }
        
        const clientWidth = mapImage.clientWidth;
        const clientHeight = mapImage.clientHeight;
        const naturalWidth = mapImage.naturalWidth;
        const naturalHeight = mapImage.naturalHeight;
        
        if (!clientWidth || !clientHeight || !naturalWidth || !naturalHeight) {
            return;
        }
        
        const scaleX = clientWidth / naturalWidth;
        const scaleY = clientHeight / naturalHeight;
        
        interactiveAreasContainer.innerHTML = '';
        
        if (!interactiveAreas || interactiveAreas.length === 0) {
            console.warn('Интерактивные области отсутствуют или не загружены.');
            return;
        }
        
        interactiveAreas.forEach(areaConfig => {
            const validation = validateAreaBounds(areaConfig, naturalWidth, naturalHeight);
            if (!validation.isValid) {
                console.warn(`Область "${areaConfig.name || 'без названия'}" пропущена: ${validation.errors.join('; ')}`);
                return;
            }

            const area = createInteractiveArea(areaConfig, scaleX, scaleY);
            interactiveAreasContainer.appendChild(area);
        });
    }
    
    function loadMapImage() {
        if (!mapImage) {
            return;
        }
        
        if (!mapImagePath) {
            console.warn('Путь к изображению карты не указан. Укажите путь в переменной mapImagePath.');
            return;
        }
        
        // Нормализуем путь (конвертируем обратные слеши в прямые)
        // Для локальных файлов через file:// используем относительный путь или file:// URL
        let imageSrc = mapImagePath;
        
        // Если это абсолютный путь Windows и файл открыт через file://, конвертируем в file:// URL
        if (/^[A-Za-z]:/.test(mapImagePath) && window.location.protocol === 'file:') {
            imageSrc = convertToFileUrl(mapImagePath);
        } else {
            // Иначе просто нормализуем путь
            imageSrc = normalizePath(mapImagePath);
        }
        
        mapImage.src = imageSrc;
        
        if (mapImage.complete && mapImage.naturalWidth) {
            mapReady = true;
            renderInteractiveAreas();
            return;
        }
        
        mapImage.addEventListener('load', function() {
            mapReady = true;
            renderInteractiveAreas();
        });
        
        mapImage.addEventListener('error', function() {
            console.error('Не удалось загрузить изображение карты по пути:', mapImagePath);
            console.warn('Попробуйте использовать относительный путь (например, "yard_map.jpg") или запустите через веб-сервер.');
        });
    }
    
    async function loadInteractiveAreas() {
        if (!interactiveAreasPath) {
            console.warn('Путь к файлу интерактивных областей не указан. Укажите путь в переменной interactiveAreasPath.');
            return;
        }
        
        // Нормализуем путь
        let areasUrl = interactiveAreasPath;
        
        // Если это абсолютный путь Windows и файл открыт через file://, конвертируем в file:// URL
        if (/^[A-Za-z]:/.test(interactiveAreasPath) && window.location.protocol === 'file:') {
            areasUrl = convertToFileUrl(interactiveAreasPath);
        } else {
            // Иначе просто нормализуем путь
            areasUrl = normalizePath(interactiveAreasPath);
        }
        
        try {
            const response = await fetch(areasUrl);
            
            if (!response.ok) {
                throw new Error('Код ответа: ' + response.status);
            }
            
            const text = await response.text();
            const parsedAreas = parseInteractiveAreasString(text);
            
            if (Array.isArray(parsedAreas) && parsedAreas.length > 0) {
                interactiveAreas = parsedAreas;
                areasReady = true;
                renderInteractiveAreas();
            } else {
                console.warn('Файл интерактивных областей загружен, но данных нет.');
            }
        } catch (error) {
            if (error.message && (error.message.includes('CORS') || error.message.includes('Failed to fetch'))) {
                console.error('Ошибка CORS при загрузке интерактивных областей. Для работы с локальными файлами необходимо запустить веб-сервер (например, через Python: python -m http.server или через Live Server в VS Code).');
                console.warn('Альтернатива: используйте относительные пути (например, "interactiveAreas.json") вместо абсолютных путей Windows.');
            } else {
                console.error('Ошибка загрузки интерактивных областей:', error);
            }
        }
    }

    // Инициализация при загрузке страницы
    document.addEventListener('DOMContentLoaded', function() {
        mapImage = document.getElementById('map-image');
        interactiveAreasContainer = document.getElementById('interactive-areas');
        
        loadMapImage();
        loadInteractiveAreas();
        
        // Парсим данные
        if (externalData) {
            if (typeof externalData === 'string') {
                try {
                    parsedData = parseDataString(externalData);
                } catch (error) {
                    console.error(error.message);
                }
            } else if (Array.isArray(externalData)) {
                parsedData = externalData;
            }
        }
        
        // Закрытие попапа при клике вне его
        document.addEventListener('click', function(e) {
            const popup = document.getElementById('popup');
            if (!popup.contains(e.target) && !e.target.classList.contains('interactive-area')) {
                closePopup();
            }
        });
        
        window.addEventListener('resize', function() {
            renderInteractiveAreas();
        });
    });
</script></body></html>